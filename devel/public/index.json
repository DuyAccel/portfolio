[{"content":"\u003cp\u003eIn my previous \u003ca href=\"https://website.duy.io.vn/blogs/website-with-cd/\"\u003eblog\u003c/a\u003e, I introduced basic steps to create a continuous deployment for portfolio website on EC2 instance. This time, I will focus on configurating a VPS to improve security and scalability on my my webservices.\u003c/p\u003e\n\u003cp\u003eIn this project, Nginx will serve as a gateway to multiple services, providing a unified access point while keeping individual ports hidden from direct exposure to the public internet. This setup not only improves security but also simplifies the management of different services by routing traffic efficiently.\u003c/p\u003e\n\u003ch2 id=\"requirements\"\u003eRequirements\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eYour domain name.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eYou need a valid domain name to config reverse proxy and obtain SSL certificate. In term of scalability, we can use sub-domains to access different services.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA linux VPS with docker enginee installed.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI\u0026rsquo;m using AWS EC2 instance for VPS as it provide 12 months free tier with almost 24/24 up time VPS (EC2). There are many other choices like Oracle, Azure, Google Cloud, etc,\u0026hellip; with free trial VPS service.\u003c/p\u003e\n\u003ch2 id=\"system-architecture\"\u003eSystem architecture\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/blogs/reverse-proxy-and-cert/arch.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch3 id=\"explanation\"\u003eExplanation\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eportfolio\u003c/code\u003e and \u003ccode\u003ejenkins\u003c/code\u003e container will run on their isolated private networks. \u003ccode\u003eNginx (reverse-proxy)\u003c/code\u003e is a bridge which has ability to connect and redirect request to them base on domain name. There are many advantages of this approach. Firstly, we do not need to expose service ports to public (more secure). Secondly, we can point many sub-domains to only one ip address to access multiple services on a same host. We also able to config SSL/TLS to encrypt transfer data and so on\u0026hellip;\nTake a look at our folder tree:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy-server/\n├── docker-compose.yml          # docker compose config\n├── jenkins/                    # jenkins service data\n├── nginx/                       \n│   ├── conf.d/                  \n│   │   ├── jenkins.conf        # nginx configuration for jenkins service\n│   │   └── portfolio.conf      # nginx configuration for portfolio service \n│   ├── dockerfile              # dockerfile for reverse-proxy config\n│   └── init_ssl.sh             # script to execute certificate config (make this file executable a.k.a chmod +x)\n├── schedule.txt                # cronjob schedule to renew certificates\n└── ssl.log                     # log file of renew certificates job\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"docker-compose\"\u003eDocker compose\u003c/h3\u003e\n\u003cp\u003eIn other to  deploy this system, we will organize those containers with docker compose file.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eservices:\n  portfolio:\n    image: duyaccel/personal-web:latest\n    container_name: \u0026#39;portfolio\u0026#39;\n    restart: unless-stopped\n    networks:\n      - portfolio-net\n\n  jenkins:\n    image: jenkins/jenkins:2.462.2-jdk17\n    container_name: \u0026#39;jenkins\u0026#39;\n    volumes:\n      - ./jenkins:/var/jenkins_home\n    restart: unless-stopped\n    networks:\n      - jenkins-net\n\n  reverse-proxy:\n    build:\n      context: ./nginx\n    container_name: \u0026#39;reverse-proxy\u0026#39;\n    volumes:\n      - ./nginx/conf.d:/etc/nginx/conf.d\n    ports:\n      - \u0026#39;80:80\u0026#39;\n      - \u0026#39;443:443\u0026#39;\n    restart: unless-stopped\n    networks:\n      - portfolio-net\n      - jenkins-net\n    depends_on:\n      - portfolio\n      - jenkins\n\nnetworks:\n  portfolio-net:\n    name: portfolio-network\n    driver: bridge\n  \n  jenkins-net:\n    name: jenkins-network\n    driver: bridge\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"reverse-proxy-configuration\"\u003eReverse proxy configuration\u003c/h2\u003e\n\u003ch3 id=\"config-services\"\u003eConfig services\u003c/h3\u003e\n\u003cp\u003eThere are some differences between Nginx package in most linux system and Nginx docker image. Docker image version will not have \u003ccode\u003e/site-available\u003c/code\u003e and \u003ccode\u003e/site-enable\u003c/code\u003e folders. We need to put configuration files inside \u003ccode\u003e/etc/nginx/conf.d\u003c/code\u003e folders. This is a example of \u003ccode\u003eportfolio.conf\u003c/code\u003e (similar to \u003ccode\u003ejenkins.conf\u003c/code\u003e) which will listen on port 80 (http) ipv4 address. In this case, if user try to access \u003cem\u003eduy.io.vn\u003c/em\u003e or \u003cem\u003ewebsite.duy.io.vn\u003c/em\u003e, those request will reach \u003cstrong\u003eportfolio service\u003c/strong\u003e.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eserver {\n  listen 80;\n  server_name duy.io.vn website.duy.io.vn; \n\n  location / {\n    proxy_pass                          http://portfolio:80;\n    proxy_redirect                      off;\n    proxy_set_header  Host              $http_host;\n    proxy_set_header  X-Real-IP         $remote_addr;\n    proxy_set_header  X-Forwarded-For   $proxy_add_x_forwarded_for;\n    proxy_set_header  X-Forwarded-Proto $scheme;\n    proxy_read_timeout                  900;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf you follow my \u003ccode\u003edocker-compose.yml\u003c/code\u003e configuration file, Nginx will able to reach portfolio services at \u003ccode\u003ehttp://portfolio:80\u003c/code\u003e which we are routing to.\u003c/p\u003e\n\u003cp\u003eReverse proxy dockerfile is not complicated at all. We only need Nginx load the config files and script to install SSL/TLS certificate. This is how it looks like.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eFROM nginx:1.27.1-alpine3.20\n\nCOPY ./conf.d /etc/nginx/conf.d\n\nCOPY init_ssl.sh .\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou wonder where is \u003ccode\u003ehttps\u003c/code\u003e huh? I\u0026rsquo;ll show you soon.\u003c/p\u003e\n\u003ch3 id=\"obtain-certificates\"\u003eObtain certificates\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"/blogs/reverse-proxy-and-cert/le-logo.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eLet\u0026rsquo;s encrypt\u003c/strong\u003e is a nonprofit Certificate Authority providing TLS certificates. They provide \u003cem\u003eCertbot ACME client\u003c/em\u003e to automate certificate issuance and installation with no downtime. In case of web service using Nginx, Certbot provide \u003cem\u003enginx plugin\u003c/em\u003e which make the configuration steps more easier.\u003c/p\u003e\n\u003cp\u003eWhat\u0026rsquo;s inside those SSL scripts and why I do not execute it in building image process? Certbot (Let\u0026rsquo;s encrypt) will verify our connection between user request and website through domain names. Therefore, I want to make sure that all services is running and connected before the verification process start. We will execute \u003ccode\u003einit_SSL.sh\u003c/code\u003e script inside reverse-proxy manually with \u003cstrong\u003edocker exec\u003c/strong\u003e command. This is content of that file:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e#!/bin/sh\n\napk add certbot-nginx\n\ncertbot \\\n        --nginx -m nguyenchauhieuduy@outlook.com \\\n        --agree-tos \\\n        --no-eff-email \\\n        -d duy.io.vn \\\n        -d website.duy.io.vn \\\n        -d cicd.duy.io.vn\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"deployment\"\u003eDeployment\u003c/h2\u003e\n\u003ch3 id=\"step-1-initialize-services\"\u003eStep 1: Initialize services\u003c/h3\u003e\n\u003cp\u003eLet\u0026rsquo;s push our configuration files to the host. There are many command lines to do this on Linux and \u003ccode\u003ersync\u003c/code\u003e is one of them. You should install and execute \u003ccode\u003ersync\u003c/code\u003e command similar to this one:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ersync -av -e \u0026#34;ssh -i $your-ssh-key-location\u0026#34; . username@hostname:/home/username/my-server\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen, SSH into your Host and execute docker compose file to init those services\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003essh -i $your-ssh-key-location username@hostname\ncd my-server\ndocker compose up -d --build\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"step-2-get-certificates-and-schedule-to-renew-them\"\u003eStep 2: Get certificates and schedule to renew them\u003c/h3\u003e\n\u003cp\u003eExecute \u003ccode\u003einit_SSL.ssh\u003c/code\u003e inside nginx image via docker command:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003edocker exec reverse-proxy /init_SSL.sh\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eEvery thing should run smoothly and you can access your website from browsers without security warning. Let\u0026rsquo;s encrypt certificates will expire after 90 days. They suggest us to run \u003ccode\u003erenew\u003c/code\u003e command every 12 hour to check and renew it with certbot client. I will use \u003ccode\u003ecron\u003c/code\u003e to schedule this process and print log output to \u003cem\u003eSSL.log\u003c/em\u003e file.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# content of schedule.txt\n0 0,12 * * * /usr/bin/docker exec reverse-proxy certbot renew \u0026gt;\u0026gt; /home/ubuntu/server/ssl.log\n\n# run this command to start cronjob write inside schedule.txt\ncrontab schedule.txt\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"shortcut-enhanced\"\u003eShortcut (Enhanced)\u003c/h3\u003e\n\u003cp\u003eA better way is write all those stuff inside a script file and execute them after push configuration file to host server. We will not need to copy setup script Nginx container.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e#!/bin/sh\n\ndocker compose up -d --build \u0026amp;\u0026amp;\n\ndocker exec rerverse-proxy sh -c \u0026#39;\n  apk add certbot-nginx\n  certbot \\\n          --nginx -m nguyenchauhieuduy@outlook.com \\\n          --agree-tos \\\n          --no-eff-email \\\n          -d duy.io.vn \\\n          -d website.duy.io.vn \\\n          -d cicd.duy.io.vn\n\u0026#39;\necho \u0026#39;\n0 0,12 * * * docker exec reverse-proxy certbot renew \u0026gt;\u0026gt; /home/ubuntu/my-server/ssl.log\n\u0026#39; \u0026gt; renew_ssl\n\ncrontab renew_ssl\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis way, we can eleminate most setup files and the foler will be:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy-server/\n├── docker-compose.yml\n├── jenkins/\n├── nginx/\n│   ├── conf.d/\n│   │   ├── jenkins.conf\n│   │   └── portfolio.conf\n│   └── dockerfile\n└── setup.sh    # make this file executable\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg src=\"/blogs/reverse-proxy-and-cert/script-output.png\" alt=\"\"\u003e\nYou can find my this configuration at \u003ca href=\"https://github.com/DuyAccel/system\"\u003emy github repository\u003c/a\u003e\u003c/p\u003e\n","description":"","image":"/blogs/reverse-proxy-and-cert/nginx-reverse-proxy.png","permalink":"http://localhost:1313/blogs/reverse-proxy-and-cert/","title":"Reverse proxy with SSL/TLS configuration"},{"content":"\u003cp\u003eNo more \u0026ldquo;It works on my machine\u0026rdquo;. In this blog, I will show you how I created and published a website on AWS EC2 with continuous deployment pipeline for free! Any change you make in source code will be automated compile, build and deploy within seconds once you push code into your github repository. My portfolio a.k.a this website is the result.\u003c/p\u003e\n\u003ch2 id=\"technologies-and-the-reason-i-choose-them\"\u003eTechnologies and the reason I choose them\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eDocker - for containerization.\u003c/li\u003e\n\u003cli\u003eGithub Action - for CD pipeline.\u003c/li\u003e\n\u003cli\u003eHugo + Hugo-profile theme - for website builder.\u003c/li\u003e\n\u003cli\u003eAWS EC2 - for website hosting (with docker installed).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eDocker is the most popular tool for containerization that you should familiar with. Although I have more experience on Jenkins but setting it is quite complicated. So that, I decided to use Github Action which provide 2,000 minutes runtime per month (Too enough for my need).\nI chose Hugo to build my static website as it really easy to use and can build content from .md files. Hugo-extended includes a various themes to choose for non-web developer like me.\nThere are so many ways to host a static website from Hugo framework for free. I chose EC2 mostly for learning purpose and because I have a plan to manually config my SSL certificate, reverse proxy, etc,\u0026hellip; on those webservers (find it on my future blogs).\u003c/p\u003e\n\u003ch2 id=\"build-your-website\"\u003eBuild your website\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/blogs/website-with-CD/hugo.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch3 id=\"install-hugo\"\u003eInstall Hugo\u003c/h3\u003e\n\u003cp\u003eI will install Hugo on \u003ca href=\"http://website.duy.io.vn/blogs/dev-container\"\u003emy devcontainer\u003c/a\u003e using prebuilt binary file. You can download it from \u003ca href=\"https://github.com/gohugoio/hugo/releases\"\u003ehugo release page\u003c/a\u003e. Remember to download extended version so that you can use hugo themes. These command can be use for download and install Hugo framework in your environment.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emkdir ~/hugo-install\ncd ~/hugo-install\nwget https://github.com/gohugoio/hugo/releases/download/v0.133.1/hugo_extended_0.133.1_linux-amd64.tar.gz\ntar -xzf hugo_extended_0.133.1_linux-amd64.tar.gz\nchmod +x hugo\n# Use root permission to copy hugo binary file to PATH folder.\nsudo cp hugo /usr/local/bin/    \n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"create-hugo-website-and-select-theme\"\u003eCreate hugo website and select theme\u003c/h3\u003e\n\u003cp\u003eYou can follow \u003ca href=\"https://gohugo.io/getting-started/quick-start/\"\u003eHugo guide\u003c/a\u003e to learn how to build your website. My theme is \u003ca href=\"https://github.com/gurusabarish/hugo-profile\"\u003ehugo-profile\u003c/a\u003e if you interest.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eIf you are developing inside a container (like me), remember to re-bind the ip address to 0.0.0.0. So that, your hugo website can be accessed via host bind port:\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehugo server --bind 0.0.0.0\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"create-docker-image\"\u003eCreate docker image\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"/blogs/website-with-CD/docker.png\" alt=\"\"\u003e\nAfter finish your website, lets containerize it with docker. Because using hugo development webservice is not recommend in production, I will \u003ccode\u003enginx\u003c/code\u003e. Remember to move your \u003ccode\u003ehugo-install\u003c/code\u003e folder into your workspace because we need to use hugo binary file. Don\u0026rsquo;t worry about image size since we can use docker multi-stage to copy only necesary files.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Build stage.\nFROM alpine:3.20.2 AS builder\n\n# Install needed dependencies for hugo.\nRUN apk update \u0026amp;\u0026amp; \\\n    apk add --no-cache gcompat libstdc++\n\nWORKDIR /app\n\n# Copy source code to image (change ./devel to your folder).\nCOPY ./devel . \n\n# Install hugo.\nRUN cd hugo-install \u0026amp;\u0026amp; \\\n    tar -xzf hugo_extended_0.133.0_linux-amd64.tar.gz \u0026amp;\u0026amp; \\\n    chmod +x hugo \u0026amp;\u0026amp; \\\n    mv hugo /bin/ \n\n# Clear old build. Then, rebuild website.\nRUN rm -rf public \u0026amp;\u0026amp; \\\n    hugo\n\n# Production stage. \nFROM nginx:1.27.1-alpine\n\n# Copy necesary files from build stage\nCOPY --from=builder /app/public /usr/share/nginx/html\n\nEXPOSE 80\n\nCMD [\u0026#34;nginx\u0026#34;, \u0026#34;-g\u0026#34;, \u0026#34;daemon off;\u0026#34;]\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"setting-cd-pipeline\"\u003eSetting CD pipeline\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/blogs/website-with-CD/github-action.png\" alt=\"\"\u003e\nIn order to use Github Action, you need to create \u003ccode\u003e.github/workflows\u003c/code\u003e folder in root project (same folder with \u003ccode\u003e.git\u003c/code\u003e). Then, create a \u003ccode\u003e.yml\u003c/code\u003e file in \u003ccode\u003e.github/workflows\u003c/code\u003e. Our pipline consist of 4 main steps:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDownload source code from repository.\u003c/li\u003e\n\u003cli\u003eBuild image from source.\u003c/li\u003e\n\u003cli\u003ePush image into docker hub.\u003c/li\u003e\n\u003cli\u003eSSH into server, pull image and run container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis is my \u003ccode\u003eCD.yml\u003c/code\u003e contain pipeline of those steps:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ename: Create and publish a Docker image\non:\n  push:\n    branches: [\u0026#39;main\u0026#39;]\n  workflow_dispatch:\n\nenv:\n  REGISTRY: docker.io \n  USER_NAME: duyaccel\n  IMAGE_NAME: duyaccel/personal-web\n  SSH_KEY: ${{ secrets.SSH_KEY }}\n  SERVER: ${{ secrets.SERVER }}\n  SV_USER: ${{ secrets.SV_USER }}\n  \n\njobs:\n  continuous_deployment:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      packages: write\n      attestations: write\n      id-token: write\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v4\n        with:\n          submodules: \u0026#39;true\u0026#39;\n\n      - name: Log in to the Container registry\n        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1\n        with:\n          registry: ${{ env.REGISTRY }}\n          username: ${{ env.USER_NAME }}\n          password: ${{ secrets.DOCKER_TOKEN }}\n\n      - name: Extract metadata (tags, labels) for Docker\n        id: meta\n        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7\n        with:\n          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\n\n      - name: Build and push Docker image\n        id: push\n        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4\n        with:\n          context: .\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n\n      - name: Deploy website\n        run: |\n          echo \u0026#34;$SSH_KEY\u0026#34; \u0026gt; private_key \u0026amp;\u0026amp; chmod 600 private_key\n          ssh -o StrictHostKeyChecking=no -i private_key ${SV_USER}@${SERVER} \u0026#39;\n            docker rm -f portfolio || true\n            docker image prune -af\n            docker run -d --name portfolio -p 80:80 duyaccel/personal-web:main\n           \u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf you wonder what is:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  ${{ secrets.DOCKER_TOKEN }}\n  SSH_KEY: ${{ secrets.SSH_KEY }}\n  SERVER: ${{ secrets.SERVER }}\n  SV_USER: ${{ secrets.SV_USER }}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg src=\"/blogs/website-with-CD/secrets.png\" alt=\"\"\u003e\nThe answer is github secrets, we will need to add them to github repository before execute pipeline. Go to \u003ccode\u003eyour repository -\u0026gt; Settings -\u0026gt;  Security -\u0026gt; Secrets and variables -\u0026gt; Actions\u003c/code\u003e to add new secrets. What we need for this workflow are:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDOCKER_TOKEN: token to sign in docker accout (create in your docker account setting).\u003c/li\u003e\n\u003cli\u003eSSH_KEY: private key to SSH connect to your host.\u003c/li\u003e\n\u003cli\u003eSERVER: host ip address.\u003c/li\u003e\n\u003cli\u003eSV_USER: username of the host.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"execute-pipeline\"\u003eExecute pipeline\u003c/h2\u003e\n\u003cp\u003eHaving \u003ccode\u003e.github/workflows/CD.yml\u003c/code\u003e, you just need to push code to your repository and wait for it to be executed. We can view the progress in \u003ccode\u003eActions tab\u003c/code\u003e of the repository.\n\u003cimg src=\"/blogs/website-with-CD/workflow.png\" alt=\"\"\u003e\nIf nothing went wrong, you can find your website on your web browser by searching ip address/domain name. You can also ssh into host to check if your containers are working properly.\n\u003cimg src=\"/blogs/website-with-CD/website.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eIn this post, I introduced the way I create an continuos deployment pipeline for my portfolio website using Github Action. Though it is accessable from internet, the security warnings are really annoying. In the future, I will add SSL certificate for my website via something like reverse proxy to manage more webservices. Do you looking forward to it? By the way, thanks for reading, see you in next posts.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eReferences:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://gohugo.io/documentation\"\u003ehttps://gohugo.io/documentation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.github.com/en/Actions\"\u003ehttps://docs.github.com/en/Actions\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n","description":"auto deploy portfolio website.","image":"/blogs/website-with-CD/automation.png","permalink":"http://localhost:1313/blogs/website-with-cd/","title":"Website With Continuous Deployment"},{"content":"\u003ch1 id=\"not-only-neovim-you-can-bring-all-your-config-into-your-most-isolated-dev-environment\"\u003eNot only neovim, you can bring all your config into your most isolated dev environment!\u003c/h1\u003e\n\u003cp\u003eIf you\u0026rsquo;re a Linux user who has put some effort to \u003ccode\u003erice\u003c/code\u003e within your operating system, you probably don’t want to interact with a boring terminal screen while working, right? In this article, I’ll show you how to create a development environment inside a Docker container that preserves your config files, particularly for \u003cem\u003eNeovim\u003c/em\u003e. The best part is you can reuse them anywhere, as long as the system has Docker Engine installed.\u003c/p\u003e\n\u003cp\u003eThe idea came from a comment on \u003ca href=\"https://www.reddit.com/r/neovim/comments/169sls2/comment/jz3wj2j/?utm_source=share\u0026amp;utm_medium=web3x\u0026amp;utm_name=web3xcss\u0026amp;utm_term=1\u0026amp;utm_content=share_button\"\u003eReddit\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"issues\"\u003eIssues\u003c/h2\u003e\n\u003ch3 id=\"why-use-a-devcontainer\"\u003eWhy use a devcontainer?\u003c/h3\u003e\n\u003cp\u003eIsolating and ensuring a clean development environment is a fundamental requirement for every developer when starting a project. There are many different methods to support this, such as:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUsing \u003ccode\u003evirtual environments\u003c/code\u003e for programming languages like Python, Node.js, etc.\u003c/li\u003e\n\u003cli\u003eUsing \u003ccode\u003econda environments\u003c/code\u003e provided by Anaconda.\u003c/li\u003e\n\u003cli\u003eUsing \u003ccode\u003evirtual machines\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eEach method has its own pros and cons: \u003ccode\u003evirtual environments\u003c/code\u003e and \u003ccode\u003econda environments\u003c/code\u003e can\u0026rsquo;t install packages outside the scope of the package manager. \u003ccode\u003eVirtual machines\u003c/code\u003e allow more freedom in package installation but are more storage-intensive. These issues can be addressed by using \u003ccode\u003econtainers\u003c/code\u003e as a development environment.\u003c/p\u003e\n\u003cp\u003eA \u003ccode\u003econtainer\u003c/code\u003e, specifically referring to Docker containers in this article, is a tool that allows for the virtualization of operating systems running on the computer’s hardware through a container engine. Since \u003ccode\u003econtainers\u003c/code\u003e do not virtualize hardware like RAM and hard drives, they save significantly more space and memory compared to \u003ccode\u003evirtual machines\u003c/code\u003e. For instance, the Docker image for the Alpine Linux operating system is only 5MB.\u003c/p\u003e\n\u003ch3 id=\"why-is-configuration-necessary\"\u003eWhy is configuration necessary?\u003c/h3\u003e\n\u003cp\u003eYou\u0026rsquo;ve put effort into configuring your code editor to your liking with all the plugins you need, but when you start working with a container, your Neovim inside the container is bare. It’s hard to accept, right? You could reinstall, but what if you need to work on multiple projects? As a developer, you should find ways to automate repetitive tasks.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/blogs/dev-container/img-0.png\" alt=\"neovim-empty-vs-config\"\u003e\u003c/p\u003e\n\u003ch3 id=\"why-not-use-vscodes-devcontainer\"\u003eWhy not use VSCode’s devcontainer?\u003c/h3\u003e\n\u003cp\u003eFor those using VSCode, you might be familiar with the dev container extension developed by Microsoft. However, I am a hardcore Neovim user, and using VSCode does not sit well with me. If you\u0026rsquo;re like me, let’s get started.\u003c/p\u003e\n\u003ch2 id=\"1-preparation\"\u003e1. Preparation\u003c/h2\u003e\n\u003cp\u003eEnsure that you have Docker installed and know how to use it at a basic level. Identify the config files that need to be included in the container.\u003c/p\u003e\n\u003ch3 id=\"11-storing-system-configurations\"\u003e1.1. Storing System Configurations\u003c/h3\u003e\n\u003cp\u003eGNU Stow is an essential tool for managing system configurations. If you\u0026rsquo;re not familiar with it, here’s a brief explanation. Suppose your HOME directory is structured as follows:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e~/\n├──dotfiles/\n|   ├── .zshrc\n|   └── .config/\n|       └── nvim/\n|           └── init.lua\n└── example.txt\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow, if you use the \u003ccode\u003estow .\u003c/code\u003e command in the \u003ccode\u003e~/dotfiles/\u003c/code\u003e directory:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ecd ~/dotfiles\nstow .\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe directories inside \u003ccode\u003edotfiles\u003c/code\u003e will be mapped to \u003ccode\u003e~/\u003c/code\u003e as follows:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e~/\n├──dotfiles/\n|   ├── .zshrc\n|   └── .config/\n|       └── nvim/\n|           └── init.lua\n├── .zshrc -\u0026gt; ~/dotfiles/.zshrc\n├── .config/\n|   └── nvim/\n|       └── init.lua -\u0026gt; ~/dotfiles/.config/nvim/init.lua\n└── example.txt\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSo, make sure the config files you want to use are consolidated into a folder like \u003ccode\u003edotfiles\u003c/code\u003e.\u003c/p\u003e\n\u003ch3 id=\"12-backing-up-configuration-files-to-github\"\u003e1.2. Backing Up Configuration Files to Github\u003c/h3\u003e\n\u003cp\u003eGithub is a great tool for this purpose. However, make sure you don’t accidentally upload any sensitive information online.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ecd ~/dotfiles\ngit init\ngit add .\ngit commit -m \u0026#39;init dotfiles\u0026#39;\n\n# Add your remote repository\ngit remote add origin https://github.com/your-github/repository.git\ngit push origin main\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"2-configuring-the-dev-container\"\u003e2. Configuring the Dev Container\u003c/h2\u003e\n\u003ch3 id=\"21-building-the-dockerfile\"\u003e2.1. Building the Dockerfile\u003c/h3\u003e\n\u003cp\u003eYou can use an image corresponding to the distro you are familiar with to ease your setup. Since \u003ccode\u003eI use Arch, btw\u003c/code\u003e, I previously used an image for this distro as a devcontainer, but its size was quite large. Therefore, in this article, we will use \u003ccode\u003eAlpine\u003c/code\u003e, a very lightweight Docker image that is well-known among Docker users. Below is my \u003cstrong\u003eDockerfile\u003c/strong\u003e. You can modify the packages to install, the username, and replace the path when cloning the Github repository.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eFROM alpine:3.20.2\n\nRUN apk update \u0026amp;\u0026amp; \\\n    apk add --no-cache git stow npm eza neovim fzf ripgrep \\\n            zsh zsh-autosuggestions zsh-syntax-highlighting \\\n            curl build-base \u0026amp;\u0026amp; \\ \n    curl -s https://ohmyposh.dev/install.sh | sh -s -- -d /usr/local/bin\n\nRUN adduser -G wheel -s /bin/zsh -u 1000 -D duy\n\nUSER duy\n\nRUN git clone https://github.com/DuyAccel/dotfiles.git ~/dotfiles \u0026amp;\u0026amp; \\\n    cd ~/dotfiles \u0026amp;\u0026amp; \\\n    stow .\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLet’s break down what’s written here:\u003c/p\u003e\n\u003cp\u003eFirst, I declare the base image as \u003cem\u003eAlpine:3.20.2\u003c/em\u003e, which is the latest version at the time of writing this article.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eFROM alpine:3.20.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNext, I update the Alpine package manager (\u003ccode\u003eapk\u003c/code\u003e) to ensure the packages are downloaded at their latest versions.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eRUN apk update \u0026amp;\u0026amp; \\\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe use the \u003ccode\u003e--no-cache\u003c/code\u003e flag to ensure \u003ccode\u003eapk\u003c/code\u003e does not cache the packages (helping to reduce the image size). The packages I install can be divided into three groups:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eEssential for Neovim:\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eneovim\u003c/code\u003e, our favorite text editor.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egit\u003c/code\u003e and \u003ccode\u003estow\u003c/code\u003e are used to fetch and apply the dotfiles stored on GitHub.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enpm\u003c/code\u003e is the package manager used to install some Neovim plugins.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eeza\u003c/code\u003e, \u003ccode\u003efzf\u003c/code\u003e, and \u003ccode\u003eripgrep\u003c/code\u003e are command-line tools necessary for Neovim plugins.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eRequired for the terminal shell:\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ezsh\u003c/code\u003e, \u003ccode\u003ezsh-autosuggestions\u003c/code\u003e, and \u003ccode\u003ezsh-syntax-highlighting\u003c/code\u003e are the Z shell and plugins for my favorite Unix shell.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eAdditional supporting tools:\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ecurl\u003c/code\u003e is used to install oh-my-posh, a tool to enhance the terminal experience.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebuild-base\u003c/code\u003e is a basic development toolset to support running and building certain files during development.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e    apk add --no-cache git stow npm eza neovim fzf ripgrep \\\n            zsh zsh-autosuggestions zsh-syntax-highlighting \\\n            curl build-base \u0026amp;\u0026amp; \\ \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe following command installs \u003cstrong\u003eoh-my-posh\u003c/strong\u003e.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e    curl -s https://ohmyposh.dev/install.sh | sh -s -- -d /usr/local/bin\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI also create a new user for use instead of \u003ccode\u003eroot\u003c/code\u003e. Using a user with the same UID as the user on the host machine helps avoid permission conflicts when binding mounts between the container and the host.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eRUN adduser -G wheel -s /bin/zsh -u 1000 -D duy\n\nUSER duy\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAfter switching to the \u003ccode\u003eduy\u003c/code\u003e user, I clone the repository containing my config files and apply those configurations to the \u003ccode\u003eduy\u003c/code\u003e user using the \u003ccode\u003estow\u003c/code\u003e command.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eRUN git clone https://github.com/DuyAccel/dotfiles.git ~/dotfiles \u0026amp;\u0026amp; \\\n    cd ~/dotfiles \u0026amp;\u0026amp; \\\n    stow .\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"22-build-image--run-container\"\u003e2.2. Build Image + Run Container\u003c/h3\u003e\n\u003cp\u003eNavigate to the folder containing your Dockerfile and build + run the image. Here’s an example of how I did it:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003edocker build -t duyaccel/devcontainer .\n\ndocker run -it --name devcontainer duyaccel/devcontainer zsh\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou will see that your file paths and shell look similar to the image below.\n\u003cimg src=\"/blogs/dev-container/container-shell.png\" alt=\"container first look\"\u003e\u003c/p\u003e\n\u003cp\u003eUse the \u003ccode\u003envim\u003c/code\u003e command to open Neovim and start the configuration process.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003envim\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWait until LazyVim plugins have been fully installed, then run the command \u003ccode\u003e:MasonInstallAll\u003c/code\u003e to install plugins managed by Mason. Some plugins like \u003cem\u003eruff\u003c/em\u003e and \u003cem\u003epydebug\u003c/em\u003e might not be installable because Python is not yet installed in this container, but it should not cause any issues.\n\u003cimg src=\"/blogs/dev-container/neovim.png\" alt=\"init neovim\"\u003e\n\u003cimg src=\"/blogs/dev-container/neovim-mason.png\" alt=\"mason neovim\"\u003e\u003c/p\u003e\n\u003cp\u003eYou can install additional packages with root permissions to suit your project needs.\n\u003cimg src=\"/blogs/dev-container/devcontainer-and-host.png\" alt=\"devcontainer vs host\"\u003e\u003c/p\u003e\n\u003ch2 id=\"3-storage\"\u003e3. Storage\u003c/h2\u003e\n\u003cp\u003eYou can push the image you just created to Docker Hub and pull it down when needed without having to build the entire image from the Dockerfile again.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003edocker push duyaccel/devcontainer\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou can visit Docker Hub, find, and download my image with the tag name: \u003ccode\u003eduyaccel/devcontainer\u003c/code\u003e. The image size is only about 135 MB.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003edocker pull duyaccel/devcontainer:latest\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"summary\"\u003eSummary\u003c/h2\u003e\n\u003cp\u003eTo keep programming from becoming dry and monotonous, it’s beneficial to infuse a bit of your own touch into it to make your work environment more comfortable and enjoyable.\u003c/p\u003e\n","description":"Make your dev environment more interesting.","image":"/blogs/dev-container/container.png","permalink":"http://localhost:1313/blogs/dev-container/","title":"Custom devcontainer"}]