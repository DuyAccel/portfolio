[{"content":"","description":"","image":null,"permalink":"http://localhost:1313/blogs/website-with-cd/","title":"Website With CD"},{"content":"\u003ch1 id=\"not-only-neovim-you-can-bring-all-your-config-into-your-most-isolated-dev-environment\"\u003eNot only neovim, you can bring all your config into your most isolated dev environment!\u003c/h1\u003e\n\u003cp\u003eIf you\u0026rsquo;re a Linux user who has put some effort to \u003ccode\u003erice\u003c/code\u003e within your operating system, you probably don’t want to interact with a boring terminal screen while working, right? In this article, I’ll show you how to create a development environment inside a Docker container that preserves your config files, particularly for \u003cem\u003eNeovim\u003c/em\u003e. The best part is you can reuse them anywhere, as long as the system has Docker Engine installed.\u003c/p\u003e\n\u003cp\u003eThe idea came from a comment on \u003ca href=\"https://www.reddit.com/r/neovim/comments/169sls2/comment/jz3wj2j/?utm_source=share\u0026amp;utm_medium=web3x\u0026amp;utm_name=web3xcss\u0026amp;utm_term=1\u0026amp;utm_content=share_button\"\u003eReddit\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"issues\"\u003eIssues\u003c/h2\u003e\n\u003ch3 id=\"why-use-a-devcontainer\"\u003eWhy use a devcontainer?\u003c/h3\u003e\n\u003cp\u003eIsolating and ensuring a clean development environment is a fundamental requirement for every developer when starting a project. There are many different methods to support this, such as:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUsing \u003ccode\u003evirtual environments\u003c/code\u003e for programming languages like Python, Node.js, etc.\u003c/li\u003e\n\u003cli\u003eUsing \u003ccode\u003econda environments\u003c/code\u003e provided by Anaconda.\u003c/li\u003e\n\u003cli\u003eUsing \u003ccode\u003evirtual machines\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eEach method has its own pros and cons: \u003ccode\u003evirtual environments\u003c/code\u003e and \u003ccode\u003econda environments\u003c/code\u003e can\u0026rsquo;t install packages outside the scope of the package manager. \u003ccode\u003eVirtual machines\u003c/code\u003e allow more freedom in package installation but are more storage-intensive. These issues can be addressed by using \u003ccode\u003econtainers\u003c/code\u003e as a development environment.\u003c/p\u003e\n\u003cp\u003eA \u003ccode\u003econtainer\u003c/code\u003e, specifically referring to Docker containers in this article, is a tool that allows for the virtualization of operating systems running on the computer’s hardware through a container engine. Since \u003ccode\u003econtainers\u003c/code\u003e do not virtualize hardware like RAM and hard drives, they save significantly more space and memory compared to \u003ccode\u003evirtual machines\u003c/code\u003e. For instance, the Docker image for the Alpine Linux operating system is only 5MB.\u003c/p\u003e\n\u003ch3 id=\"why-is-configuration-necessary\"\u003eWhy is configuration necessary?\u003c/h3\u003e\n\u003cp\u003eYou\u0026rsquo;ve put effort into configuring your code editor to your liking with all the plugins you need, but when you start working with a container, your Neovim inside the container is bare. It’s hard to accept, right? You could reinstall, but what if you need to work on multiple projects? As a developer, you should find ways to automate repetitive tasks.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/blogs/dev-container/img-0.png\" alt=\"neovim-empty-vs-config\"\u003e\u003c/p\u003e\n\u003ch3 id=\"why-not-use-vscodes-devcontainer\"\u003eWhy not use VSCode’s devcontainer?\u003c/h3\u003e\n\u003cp\u003eFor those using VSCode, you might be familiar with the dev container extension developed by Microsoft. However, I am a hardcore Neovim user, and using VSCode does not sit well with me. If you\u0026rsquo;re like me, let’s get started.\u003c/p\u003e\n\u003ch2 id=\"1-preparation\"\u003e1. Preparation\u003c/h2\u003e\n\u003cp\u003eEnsure that you have Docker installed and know how to use it at a basic level. Identify the config files that need to be included in the container.\u003c/p\u003e\n\u003ch3 id=\"11-storing-system-configurations\"\u003e1.1. Storing System Configurations\u003c/h3\u003e\n\u003cp\u003eGNU Stow is an essential tool for managing system configurations. If you\u0026rsquo;re not familiar with it, here’s a brief explanation. Suppose your HOME directory is structured as follows:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e~/\n├──dotfiles/\n|   ├── .zshrc\n|   └── .config/\n|       └── nvim/\n|           └── init.lua\n└── example.txt\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow, if you use the \u003ccode\u003estow .\u003c/code\u003e command in the \u003ccode\u003e~/dotfiles/\u003c/code\u003e directory:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ecd ~/dotfiles\nstow .\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe directories inside \u003ccode\u003edotfiles\u003c/code\u003e will be mapped to \u003ccode\u003e~/\u003c/code\u003e as follows:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e~/\n├──dotfiles/\n|   ├── .zshrc\n|   └── .config/\n|       └── nvim/\n|           └── init.lua\n├── .zshrc -\u0026gt; ~/dotfiles/.zshrc\n├── .config/\n|   └── nvim/\n|       └── init.lua -\u0026gt; ~/dotfiles/.config/nvim/init.lua\n└── example.txt\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSo, make sure the config files you want to use are consolidated into a folder like \u003ccode\u003edotfiles\u003c/code\u003e.\u003c/p\u003e\n\u003ch3 id=\"12-backing-up-configuration-files-to-github\"\u003e1.2. Backing Up Configuration Files to Github\u003c/h3\u003e\n\u003cp\u003eGithub is a great tool for this purpose. However, make sure you don’t accidentally upload any sensitive information online.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ecd ~/dotfiles\ngit init\ngit add .\ngit commit -m \u0026#39;init dotfiles\u0026#39;\n\n# Add your remote repository\ngit remote add origin https://github.com/your-github/repository.git\ngit push origin main\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"2-configuring-the-dev-container\"\u003e2. Configuring the Dev Container\u003c/h2\u003e\n\u003ch3 id=\"21-building-the-dockerfile\"\u003e2.1. Building the Dockerfile\u003c/h3\u003e\n\u003cp\u003eYou can use an image corresponding to the distro you are familiar with to ease your setup. Since \u003ccode\u003eI use Arch, btw\u003c/code\u003e, I previously used an image for this distro as a devcontainer, but its size was quite large. Therefore, in this article, we will use \u003ccode\u003eAlpine\u003c/code\u003e, a very lightweight Docker image that is well-known among Docker users. Below is my \u003cstrong\u003eDockerfile\u003c/strong\u003e. You can modify the packages to install, the username, and replace the path when cloning the Github repository.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eFROM alpine:3.20.2\n\nRUN apk update \u0026amp;\u0026amp; \\\n    apk add --no-cache git stow npm eza neovim fzf ripgrep \\\n            zsh zsh-autosuggestions zsh-syntax-highlighting \\\n            curl build-base \u0026amp;\u0026amp; \\ \n    curl -s https://ohmyposh.dev/install.sh | sh -s -- -d /usr/local/bin\n\nRUN adduser -G wheel -s /bin/zsh -u 1000 -D duy\n\nUSER duy\n\nRUN git clone https://github.com/DuyAccel/dotfiles.git ~/dotfiles \u0026amp;\u0026amp; \\\n    cd ~/dotfiles \u0026amp;\u0026amp; \\\n    stow .\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLet’s break down what’s written here:\u003c/p\u003e\n\u003cp\u003eFirst, I declare the base image as \u003cem\u003eAlpine:3.20.2\u003c/em\u003e, which is the latest version at the time of writing this article.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eFROM alpine:3.20.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNext, I update the Alpine package manager (\u003ccode\u003eapk\u003c/code\u003e) to ensure the packages are downloaded at their latest versions.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eRUN apk update \u0026amp;\u0026amp; \\\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe use the \u003ccode\u003e--no-cache\u003c/code\u003e flag to ensure \u003ccode\u003eapk\u003c/code\u003e does not cache the packages (helping to reduce the image size). The packages I install can be divided into three groups:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eEssential for Neovim:\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eneovim\u003c/code\u003e, our favorite text editor.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egit\u003c/code\u003e and \u003ccode\u003estow\u003c/code\u003e are used to fetch and apply the dotfiles stored on GitHub.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enpm\u003c/code\u003e is the package manager used to install some Neovim plugins.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eeza\u003c/code\u003e, \u003ccode\u003efzf\u003c/code\u003e, and \u003ccode\u003eripgrep\u003c/code\u003e are command-line tools necessary for Neovim plugins.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eRequired for the terminal shell:\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ezsh\u003c/code\u003e, \u003ccode\u003ezsh-autosuggestions\u003c/code\u003e, and \u003ccode\u003ezsh-syntax-highlighting\u003c/code\u003e are the Z shell and plugins for my favorite Unix shell.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eAdditional supporting tools:\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ecurl\u003c/code\u003e is used to install oh-my-posh, a tool to enhance the terminal experience.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebuild-base\u003c/code\u003e is a basic development toolset to support running and building certain files during development.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e    apk add --no-cache git stow npm eza neovim fzf ripgrep \\\n            zsh zsh-autosuggestions zsh-syntax-highlighting \\\n            curl build-base \u0026amp;\u0026amp; \\ \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe following command installs \u003cstrong\u003eoh-my-posh\u003c/strong\u003e.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e    curl -s https://ohmyposh.dev/install.sh | sh -s -- -d /usr/local/bin\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI also create a new user for use instead of \u003ccode\u003eroot\u003c/code\u003e. Using a user with the same UID as the user on the host machine helps avoid permission conflicts when binding mounts between the container and the host.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eRUN adduser -G wheel -s /bin/zsh -u 1000 -D duy\n\nUSER duy\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAfter switching to the \u003ccode\u003eduy\u003c/code\u003e user, I clone the repository containing my config files and apply those configurations to the \u003ccode\u003eduy\u003c/code\u003e user using the \u003ccode\u003estow\u003c/code\u003e command.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eRUN git clone https://github.com/DuyAccel/dotfiles.git ~/dotfiles \u0026amp;\u0026amp; \\\n    cd ~/dotfiles \u0026amp;\u0026amp; \\\n    stow .\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"22-build-image--run-container\"\u003e2.2. Build Image + Run Container\u003c/h3\u003e\n\u003cp\u003eNavigate to the folder containing your Dockerfile and build + run the image. Here’s an example of how I did it:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003edocker build -t duyaccel/devcontainer .\n\ndocker run -it --name devcontainer duyaccel/devcontainer zsh\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou will see that your file paths and shell look similar to the image below.\n\u003cimg src=\"/blogs/dev-container/container-shell.png\" alt=\"container first look\"\u003e\u003c/p\u003e\n\u003cp\u003eUse the \u003ccode\u003envim\u003c/code\u003e command to open Neovim and start the configuration process.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003envim\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWait until LazyVim plugins have been fully installed, then run the command \u003ccode\u003e:MasonInstallAll\u003c/code\u003e to install plugins managed by Mason. Some plugins like \u003cem\u003eruff\u003c/em\u003e and \u003cem\u003epydebug\u003c/em\u003e might not be installable because Python is not yet installed in this container, but it should not cause any issues.\n\u003cimg src=\"/blogs/dev-container/neovim.png\" alt=\"init neovim\"\u003e\n\u003cimg src=\"/blogs/dev-container/neovim-mason.png\" alt=\"mason neovim\"\u003e\u003c/p\u003e\n\u003cp\u003eYou can install additional packages with root permissions to suit your project needs.\n\u003cimg src=\"/blogs/dev-container/devcontainer-and-host.png\" alt=\"devcontainer vs host\"\u003e\u003c/p\u003e\n\u003ch2 id=\"3-storage\"\u003e3. Storage\u003c/h2\u003e\n\u003cp\u003eYou can push the image you just created to Docker Hub and pull it down when needed without having to build the entire image from the Dockerfile again.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003edocker push duyaccel/devcontainer\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou can visit Docker Hub, find, and download my image with the tag name: \u003ccode\u003eduyaccel/devcontainer\u003c/code\u003e. The image size is only about 135 MB.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003edocker pull duyaccel/devcontainer:latest\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"summary\"\u003eSummary\u003c/h2\u003e\n\u003cp\u003eTo keep programming from becoming dry and monotonous, it’s beneficial to infuse a bit of your own touch into it to make your work environment more comfortable and enjoyable.\u003c/p\u003e\n","description":"Make your dev environment more interesting.","image":"/blogs/dev-container/container.png","permalink":"http://localhost:1313/blogs/dev-container/","title":"Custom devcontainer"}]